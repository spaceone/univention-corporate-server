#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Univention Management Console
#  Univention Directory Manager Module
#
# Copyright 2017 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import json
import copy
import urllib
import base64
import binascii
import logging
from logging.handlers import TimedRotatingFileHandler
from urlparse import urljoin

import tornado.ioloop
from tornado.web import Application, RequestHandler
from tornado.concurrent import run_on_executor
from concurrent.futures import ThreadPoolExecutor

from ldap.filter import filter_format

from univention.management.console.config import ucr
from univention.management.console.ldap import get_user_connection, get_machine_connection
from univention.management.console.modules.udm.udm_ldap import get_module, set_bind_function, UDM_Module, ldap_dn2path, read_syntax_choices, UDM_Settings, _get_syntax, container_modules, UDM_Error
import univention.directory.reports as udr
import univention.admin.uexceptions as udm_errors
import univention.admin.modules as udm_modules
# TODO: PAM authentication ?
# TODO: threads?
# TODO: use http link header
# TODO: set Last-Modified
# FIXME: add_asterisks sanitizer
# FIXME: prevent in the javascript that navigation container quer is called with container=='None'
# TODO: translation


MAX_WORKERS = 4

logger = logging.getLogger('umc-udm')
if 'umc-udm-trfh' not in logger.handlers:
	handler = TimedRotatingFileHandler('/var/log/univention/umc-udm.log', when='D', interval=7)
	handler.set_name('umc-udm-trfh')
	handler.setLevel(logging.DEBUG)  # TODO: set to info or warn
	logger.addHandler(handler)
	logger.setLevel(logging.DEBUG)  # TODO: set to info or warn


class Ressource(RequestHandler):
	executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)

	def force_authorization(self):
		self.set_header('WWW-Authenticate', 'Basic realm="Univention Management Console"')
		self.set_status(401)
		self.finish()

	def prepare(self):
		authorization = self.request.headers.get('Authorization')
		if not authorization:
			return self.force_authorization()

		try:
			if not authorization.lower().startswith('basic '):
				raise ValueError()
			username, password = base64.decodestring(authorization.split(' ', 1)[1]).split(':', 1)
		except (ValueError, IndexError, binascii.Error):
			raise BadRequest()

		# TODO: caching
		lo, po = get_machine_connection()
		try:
			userdn = lo.searchDn(filter_format('(&(objectClass=person)(uid=%s))', [username]), unique=True)[0]
			self.ldap_connection, self.ldap_position = get_user_connection(bind=lambda lo: lo.bind(userdn, password))
			set_bind_function(lambda lo: lo.bind(userdn, password))
		except:
			return self.force_authorization()

	def get_module(self, object_type):
		module = UDM_Module(object_type)
		if not module or not module.module:
			raise NotFound(object_type)
		return module

	def get_object(self, object_type, dn):
		module = self.get_module(object_type)
		obj = module.get(dn)
		if not obj:
			raise NotFound(object_type, dn)
		return obj

	def content_negotiation(self, response):
		# TODO; parse Accept header correctly with quality value
		# TODO: implement XML
		lang = 'html'
		if 'application/json' in self.request.header.get('Accept', ''):
			lang = 'json'
		func = getattr(self, '%s_%s' % (self.request.method.lower(), lang), lambda x: x)
		getattr(self, 'content_negotiation_%s' % (lang,))(func(response))
		self.finish()

	def content_negotiation_json(self, response):
		self.set_header('Content-Type', 'application/json')
		self.write(json.dumps(response))

	def content_negotiation_html(self, response):
		self.set_header('Content-Type', 'text/html')
		self.write(response)


def xml_rendering():
	import xml.etree.cElementTree as ET

	root = ET.Element("root")
	doc = ET.SubElement(root, "doc")

	ET.SubElement(doc, "field1", name="blah").text = "some value1"
	ET.SubElement(doc, "field2", name="asdfasd").text = "some vlaue2"

	tree = ET.ElementTree(root)


class MainHandler(Ressource):

	def get(self):
		for main_type in ('users', 'computers', 'groups', 'networks', 'dhcp', 'dns', 'shares', 'mail', 'nagios', 'policies'):  # ldap-navigation?
			self.add_header('Link', '</udm/%s/>; rel="/udm/object-modules"; title=""' % (main_type,))
		self.write("Hello, world")


class MainTypes(Ressource):

	def get(self, main_type):
		sub_type = 'user'
		self.add_header('Link', '</udm/%s/%s/>; rel="/udm/object-types"; title=""' % (main_type, sub_type))
		self.write("Hello, world")


class ObjectTypes(Ressource):
	"""get the object types of a specific flavor"""

	def get(self, object_type):
		"""Returns the list of object types matching the given flavor or container.

		requests.options = {}
			'superordinate' -- if available only types for the given superordinate are returned (not for the navigation)
			'container' -- if available only types suitable for the given container are returned (only for the navigation)
		"""
		superordinate = self.get_query_argument('superordinate', None)
		module = UDM_Module(object_type)
		if superordinate:
			module = get_module(object_type, superordinate) or module  # FIXME: the object_type param is wrong?!
		result = module.child_modules
		self.content_negotiation(result)


class ObjectTypesNavigation(Ressource):

	def get(self):
		superordinate = self.get_query_argument('superordinate', None)
		container = self.get_query_argument('container', None) or superordinate
		if not container:
			# no container is specified, return all existing object types
			result = [{
				'id': module[0],
				'label': getattr(module[1], 'short_description', module[0])
			} for module in udm_modules.modules.items()]
			self.content_negotiation(result)
			return

		if 'None' == container:
			# if 'None' is given, use the LDAP base
			container = ucr.get('ldap/base')

		# create a list of modules that can be created
		# ... all container types except container/dc
		allowed_modules = set([m for m in udm_modules.containers if udm_modules.name(m) != 'container/dc'])

		# the container may be a superordinate or have one as its parent
		# (or grandparent, ....)
		superordinate = udm_modules.find_superordinate(container, None, self.ldap_connection)
		if superordinate:
			# there is a superordinate... add its subtypes to the list of allowed modules
			allowed_modules.update(udm_modules.subordinates(superordinate))
		else:
			# add all types that do not have a superordinate
			allowed_modules.update(mod for mod in udm_modules.modules.values() if not udm_modules.superordinates(mod))

		# make sure that the object type can be created
		allowed_modules = [mod for mod in allowed_modules if udm_modules.supports(mod, 'add')]

		# return the final list of object types
		result = [{
			'id': udm_modules.name(module),
			'label': getattr(module, 'short_description', udm_modules.name(module))
		} for module in allowed_modules]
		self.content_negotiation(result)


class ContainerQueryBase(Ressource):

	def _container_query(self, object_type, container, modules, scope):
		"""Get a list of containers or child objects of the specified container."""

		if not container:
			container = ucr['ldap/base']
			defaults = {}
			if object_type != 'navigation':
				defaults['$operations$'] = ['search', ],  # disallow edit
			if object_type in ('dns/dns', 'dhcp/dhcp'):
				defaults.update({
					'label': UDM_Module(object_type).title,
					'icon': 'udm-%s' % (object_type.replace('/', '-'),),
				})
			return [dict({
				'id': container,
				'label': ldap_dn2path(container),
				'icon': 'udm-container-dc',
				'path': ldap_dn2path(container),
				'objectType': 'container/dc',
				'$operations$': UDM_Module('container/dc').operations,
				'$flags$': [],
				'$childs$': True,
				'$isSuperordinate$': False,
			}, **defaults)]

		result = []
		for xmodule in modules:
			xmodule = UDM_Module(xmodule)
			superordinate = None
			if xmodule.superordinate_names:
				for module_superordinate in xmodule.superordinate_names:
					try:
						superordinate = UDM_Module(module_superordinate).get(container)
					except UDM_Error:  # the container is not a direct superordinate  # FIXME: get the "real" superordinate; Bug #40885
						continue
				if superordinate is None:
					continue  # superordinate object could not be load -> ignore module
			try:
				for item in xmodule.search(container, scope=scope, superordinate=superordinate):
					module = UDM_Module(item.module)
					result.append({
						'id': item.dn,
						'label': item[module.identifies],
						'icon': 'udm-%s' % (module.name.replace('/', '-')),
						'path': ldap_dn2path(item.dn),
						'objectType': module.name,
						'$operations$': module.operations,
						'$flags$': item.oldattr.get('univentionObjectFlag', []),
						'$childs$': module.childs,
						'$isSuperordinate$': udm_modules.isSuperordinate(module.module),
					})
			except UDM_Error as exc:
				raise UMC_Error(str(exc))

		return result


class Navigation(ContainerQueryBase):
	"""GET udm/(dns|dhcp|)/navigation/ (the tree content of navigation/DNS/DHCP)"""

	def get(self, object_type):
		ldap_base = ucr['ldap/base']
		container = self.get_query_argument('container', None)

		modules = container_modules()
		scope = 'one'
		if not container:
			# get the tree root == the ldap base
			scope = 'base'
		elif object_type != 'navigation' and container and ldap_base.lower() == container.lower():
			# this is the tree root of DNS / DHCP, show all zones / services
			scope = 'sub'
			modules = [object_type]

		containers = self._container_query(object_type, container, modules, scope)
		self.content_negotiation(containers)


class MoveDestinations(ContainerQueryBase):

	def get(self, object_type):
		scope = 'one'
		modules = container_modules()
		container = self.get_query_argument('container', None)
		if not container:
			scope = 'base'

		containers = self._container_query(object_type, container, modules, scope)
		self.content_negotiation(containers)


class LicenseRequest(Ressource):
	pass


class Properties(Ressource):
	"""GET udm/users/user/properties (get properties of users/user object type)"""

	def get(self, object_type, dn):
		module = self.get_module(object_type)
		module.load(force_reload=True)  # reload for instant extended attributes

		properties = module.get_properties(dn)
		searchable = self.get_query_argument('searchable', False)
		if searchable:
			properties = [prop for prop in properties if prop.get('searchable', False)]

		self.content_negotiation(properties)


class Options(Ressource):
	"""GET udm/users/user/options (get options of users/user object type)"""

	def get(self, object_type):
		"""Returns the options specified for the given object type"""
		result = self.get_module(object_type).options.keys()
		self.content_negotiation(result)


class Layout(Ressource):
	"""GET udm/users/user/$dn/layout (get layout of users/user object type)"""

	def get(self, object_type, dn=None):
		"""Returns the layout information for the given object type."""

		module = self.get_module(object_type)
		module.load(force_reload=True)  # reload for instant extended attributes

		if object_type == 'users/self':
			dn = None

		result = module.get_layout(dn)
		self.content_negotiation(result)


class Templates(Ressource):
	"""GET udm/users/user/templates (get the list of templates of users/user object type)"""

	def get(self, object_type):
		"""Returns the list of template objects for the given object"""

		module = self.get_module(object_type)
		result = []
		if module.template:
			template = UDM_Module(module.template)
			objects = template.search(ucr.get('ldap/base'))
			for obj in objects:
				obj.open()
				result.append({'id': obj.dn, 'label': obj[template.identifies]})

		self.content_negotiation(result)


class Containers(Ressource):
	"""GET udm/users/user/containers (get default containers for users/user)"""

	def get(self, object_type):
		"""Returns the list of default containers for the given object
		type. Therefor the python module and the default object in the
		LDAP directory are searched.
		"""
		module = self.get_module(object_type)
		containers = module.containers

		if self.settings is not None:
			settings = UDM_Settings()
			settings.user(self.user_dn)
			containers += settings.containers(object_type)

		containers.sort(cmp=lambda x, y: cmp(x['label'].lower(), y['label'].lower()))

		self.content_negotiation(containers)


class Policies(Ressource):
	"""GET udm/users/user/policies (get the list of policy-types that apply for users/user object type)"""

	def get(self, object_type):
		module = self.get_module(object_type)
		result = module.policies
		self.content_negotiation(result)


class ReportingBase(Ressource):

	def initialize(self):
		self.reports_cfg = udr.Config()


class ReportTypes(ReportingBase):
	"""GET udm/users/user/report-types (get report-types of users/*)"""

	def get(self, object_type):
		"""Returns a list of reports for the given object type"""
		# i18n: translattion for univention-directory-reports
		# _('PDF Document')
		_ = lambda x: x
		result = [{'id': name, 'label': _(name)} for name in sorted(self.reports_cfg.get_report_names(object_type))]
		self.content_negotiation(result)


class Report(ReportingBase):
	"""GET udm/users/user/report/$report_type (create a report of a users)"""

	def get(self, object_type, report_type):
		# TODO: POST ? with 202 accepted
		try:
			report_type in self.reports_cfg.get_report_names(object_type)
		except KeyError:
			raise NotFound(report_type)

		dns = self.get_query_arguments('dn')
		report = udr.Report(self.ldap_connection)
		try:
			report_file = report.create(object_type, report_type, dns)
		except udr.ReportError as exc:
			raise UMC_Error(str(exc))

		with open(report_file) as fd:
			self.set_header('Content-Type', 'text/csv' if report.endswith('.csv') else 'application/pdf')
			self.content_negotiation(fd.read())


class NextFreeIpAddress(Ressource):
	"""GET udm/networks/network/$DN/next-ip (get the next free IP in this network)"""

	def get(self, dn):
		"""Returns the next IP configuration based on the given network object

		requests.options = {}
			'networkDN' -- the LDAP DN of the network object
			'increaseCounter' -- if given and set to True, network object counter for IP addresses is increased

		return: {}
		"""
		obj = self.get_object('networks/network', dn)
		try:
			obj.refreshNextIp()
		except udm_errors.nextFreeIp:
			raise NoIpLeft(dn)

		result = {'ip': obj['nextIp'], 'dnsEntryZoneForward': obj['dnsEntryZoneForward'], 'dhcpEntryZone': obj['dhcpEntryZone'], 'dnsEntryZoneReverse': obj['dnsEntryZoneReverse']}

		self.content_negotiation(result)

		if self.request.get_query_argument('increaseCounter'):
			# increase the next free IP address
			obj.stepIp()
			obj.modify()


class DefaultValue(Ressource):
	"""GET udm/users/user/properties/$property/default (get the default value for the specified property)"""

	def get(self, object_type, property_):
		module = self.get_module(object_type)
		result = module.get_default_values(property_)
		self.content_negotiation(result)


class Objects(Ressource):

	@run_on_executor
	def mod_search(self, module, container, objectProperty, objectPropertyValue, superordinate, scope, hidden):
		return module.search(container, objectProperty, objectPropertyValue, superordinate, scope, hidden) or []

	@tornado.gen.coroutine
	def get(self, object_type):
		"""GET udm/users/user/ (nach Benutzern suchen)"""
		module = self.get_module(object_type)

		# TODO: replace the superordinate concept by container
		superordinate = self.get_query_argument('superordinate', None)

		container = self.get_query_argument('container', None)
		objectProperty = self.get_query_argument('objectProperty', None)
		objectPropertyValue = self.get_query_argument('objectPropertyValue', None)
		scope = self.get_query_argument('scope', 'sub')
		hidden = self.get_query_argument('hidden', False)
		fields = self.get_query_arguments('fields', [])
		fields = (set(fields) | set([objectProperty])) - set(['name', 'None', None, ''])

		if superordinate:
			mod = get_module(superordinate, superordinate)
			if not module:
				raise SuperordinateDoesNotExist(superordinate)
			superordinate = mod.get(superordinate)
			container = container or superordinate

		# result = module.search(container, objectProperty, objectPropertyValue, superordinate, scope=scope, hidden=hidden) or []
		result = yield self.mod_search(module, container, objectProperty, objectPropertyValue, superordinate, scope=scope, hidden=hidden) or []

		entries = []
		for obj in result:
			if obj is None:
				continue
			module = get_module(object_type, obj.dn)
			if module is None:
				# This happens when concurrent a object is removed between the module.search() and get_module() call
				# MODULE.warn('LDAP object does not exists %s (flavor: %s). The object is ignored.' % (obj.dn, request.flavor))
				continue

			assert '/' not in obj.dn  # TODO: escape /
			entry = {
				'$dn$': obj.dn,
				'$childs$': module.childs,
				'$flags$': obj.oldattr.get('univentionObjectFlag', []),
				'$operations$': module.operations,
				'objectType': module.name,
				'labelObjectType': module.subtitle,
				'name': module.obj_description(obj),
				'path': ldap_dn2path(obj.dn, include_rdn=False),
				'url': urljoin(self.request.path, obj.dn),
			}
			if '$value$' in fields:
				entry['$value$'] = [module.property_description(obj, column['name']) for column in module.columns]
			for field in fields - set(module.password_properties) - set(entry.keys()):
				entry[field] = module.property_description(obj, field)
			entries.append(entry)

		self.content_negotiation(entries)

	def post(self, object_type):
		"""POST udm/users/user/ (Benutzer hinzufügen)"""
		module = self.get_module(object_type)
		container = self.get_body_argument('container')
		superordinate = self.get_body_argument('superordinate')
		options = self.get_body_arguments('options')

		obj = module.module.object(None, self.ldap_connection, self.ldap_position)
		obj.open()
		obj.options = options
		properties = dict((prop, self.get_body_arguments(prop)) for prop in dict(obj.items()))

		dn = module.create(properties, container=container, superordinate=superordinate)
		self.set_header('Location', urljoin(self.request.path, urllib.quote(dn)))
		self.set_status(201)

	def options(self, object_type):
		self.set_header('Allow', 'GET, POST, OPTIONS')
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (self.request.path, 'search', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'add/'), 'create-form', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'edit/'), 'edit-form', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'favicon'), 'icon', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'properties'), 'udm/properties', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'options'), 'udm/options', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'layout'), 'udm/layout', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'templates'), 'udm/templates', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'containers'), 'udm/containers', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'policies'), 'udm/policies', ''))
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, 'report-types'), 'udm/report-types', ''))
#		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, ''), '', ''))
#		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, ''), '', ''))
#		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (urljoin(self.request.path, ''), '', ''))


class Object(Ressource):

	def get(self, object_type, dn):
		"""GET udm/users/user/$DN (get all properties/values of the user)"""
		self.add_header('Link', '<%s>; rel="%s"; title="%s"' % (self.request.path, 'self', ''))
		copy = bool(self.get_query_argument('copy', None))  # TODO: move into own ressource

		def _remove_uncopyable_properties(obj):
			if not copy:
				return
			for name, p in obj.descriptions.items():
				if not p.copyable:
					obj.info.pop(name, None)

		if object_type == 'users/self' and dn != self._user_dn:
			raise Forbidden()

		module = get_module(object_type, dn)
		obj = module.get(dn)
		if not obj:
			raise NotFound(dn)

		_remove_uncopyable_properties(obj)
		obj.set_defaults = True
		obj.set_default_values()
		_remove_uncopyable_properties(obj)
		props = obj.info
		for passwd in module.password_properties:
			if passwd in props:
				del props[passwd]
		if not copy:
			props['$dn$'] = obj.dn
		props['$options$'] = {}
		for opt in module.get_options(udm_object=obj):
			props['$options$'][opt['id']] = opt['value']
		props['$policies$'] = {}
		for policy in obj.policies:
			pol_mod = get_module(None, policy)
			if pol_mod and pol_mod.name:
				props['$policies$'].setdefault(pol_mod.name, []).append(policy)
		props['$labelObjectType$'] = module.title
		props['$flags$'] = obj.oldattr.get('univentionObjectFlag', [])
		props['$operations$'] = module.operations
		props['$references$'] = module.get_references(dn)
		assert '/' not in obj.dn  # TODO: escape /
		props['url'] = urljoin(self.request.path, obj.dn)
		self.content_negotiation(props)

	def put(self, object_type, dn):
		"""PUT udm/users/user/$DN (Benutzer hinzufügen / modifizieren)"""
		module = get_module(object_type, dn)
		if not module:
			raise NotFound(object_type)  # FIXME: create

		obj = module.module.object(None, self.ldap_connection, self.ldap_position, dn)
		obj.open()
		obj.options = self.get_body_arguments('$options$')
		properties = dict((prop, self.get_body_arguments(prop)) for prop in dict(obj.items()))
		try:
			module._map_properties(obj, properties)
			obj.modify()
		except udm_errors.base as exc:
			UDM_Error(exc).reraise()

	def patch(self, object_type, dn):
		pass

	def delete(self, object_type, dn):
		"""DELETE udm/users/user/$DN (Benutzer löschen)"""
		module = get_module(object_type, dn)
		if not module:
			raise NotFound(object_type)

		cleanup = bool(self.get_query_argument('cleanup', False))
		recursive = bool(self.get_query_argument('recursive', False))
		module.remove(dn, cleanup, recursive)

	def options(self, object_type, dn):
		self.set_header('Allow', 'GET, PUT, DELETE, OPTIONS')

	def _validate(self, object_type):
		"""Validates the correctness of values for properties of the
		given object type. Therefor the syntax definition of the properties is used.

		return: [ { 'property' : <name>, 'valid' : (True|False), 'details' : <message> }, ... ]
		"""

		module = self.get_module(object_type)

		result = []
		for property_name, value in self.request.body_arguments.items():
			# ignore special properties named like $.*$, e.g. $options$
			if property_name.startswith('$') and property_name.endswith('$'):
				continue
			property_obj = module.get_property(property_name)

			if property_obj is None:
				raise BadRequest(_('Property %s not found') % property_name)

			if not property_obj.multivalue:
				value = value[0]

			# check each element if 'value' is a list
			if isinstance(value, (tuple, list)) and property_obj.multivalue:
				subResults = []
				subDetails = []
				for ival in value:
					try:
						property_obj.syntax.parse(ival)
						subResults.append(True)
						subDetails.append('')
					except (udm_errors.valueInvalidSyntax, udm_errors.valueError, TypeError) as exc:
						subResults.append(False)
						subDetails.append(str(exc))
				result.append({'property': property_name, 'valid': subResults, 'details': subDetails})
			# otherwise we have a single value
			else:
				try:
					property_obj.syntax.parse(value)
					result.append({'property': property_name, 'valid': True})
				except (udm_errors.valueInvalidSyntax, udm_errors.valueError) as exc:
					result.append({'property': property_name, 'valid': False, 'details': str(exc)})


class PropertyChoices(Ressource):
	"""GET udm/users/user/$DN/property/$name/choices (get possible values/choices for that property)"""

	def get(self, object_type, dn, property_):
		module = self.get_module(object_type)
		try:
			syntax = module.module.property_descriptions[property_].syntax
		except KeyError:
			raise NotFound()
		request_body = {'syntax': syntax.name}  # FIXME
		choices = read_syntax_choices(_get_syntax(syntax.name), request_body)
		self.content_negotiation(choices)


class PolicyTypes(Ressource):
	"""GET udm/users/user/$DN/policies/$policy_type (get the policies of policy-type for the given object)"""

	def get(self, object_type, dn, policy_type):
		"""Returns a list of policy types that apply to the given object type"""
		module = self.get_module(object_type)
		result = module.policies
		self.content_negotiation(result)


class PolicyResult(Ressource):
	"""GET udm/users/user/policies/$policy_type/$dn?container=true...&policy=... (get the possible policies of the policy-type for user objects located at the containter)"""

	def get(self, object_type, policy_type, dn):
		"""Returns a virtual policy object containing the values that
		the given object or container inherits"""

		is_container = bool(self.get_query_argument('container', None))
		policy_dn = self.get_query_argument('policy', None)

		if is_container:
			# editing a new (i.e. non existing) object -> use the parent container
			obj = self.get_object(get_module(None, dn).module, dn)
		else:
			# editing an exiting UDM object -> use the object itself
			obj = self.get_object(object_type, dn)

		if policy_dn:
			policy_obj = self.get_object(policy_type, policy_dn)
		else:
			policy_obj = self.get_module(policy_type).get(None)
		policy_obj.clone(obj)

		# There are 2x2x2 (=8) cases that may occur (c.f., Bug #31916):
		# (1)
		#   [edit] editing existing UDM object
		#   -> the existing UDM object itself is loaded
		#   [new]  virtually edit non-existing UDM object (when a new object is being created)
		#   -> the parent container UDM object is loaded
		# (2)
		#   [w/pol]   UDM object has assigend policies in LDAP directory
		#   [w/o_pol] UDM object has no policies assigend in LDAP directory
		# (3)
		#   [inherit] user request to (virtually) change the policy to 'inherited'
		#   [set_pol] user request to (virtually) assign a particular policy
		faked_policy_reference = None
		if not is_container and not policy_dn:
			# case: [edit; w/pol; inherit]
			# -> current policy is (virtually) overwritten with 'None'
			faked_policy_reference = [None]
		elif is_container and policy_dn:
			# cases:
			# * [new; w/pol; inherit]
			# * [new; w/pol; set_pol]
			# -> old + temporary policy are both (virtually) set at the parent container
			faked_policy_reference = obj.policies + [policy_dn]
		else:
			# cases:
			# * [new; w/o_pol; inherit]
			# * [new; w/o_pol; set_pol]
			# * [edit; w/pol; set_pol]
			# * [edit; w/o_pol; inherit]
			# * [edit; w/o_pol; set_pol]
			faked_policy_reference = [policy_dn]

		policy_obj.policy_result(faked_policy_reference)
		infos = copy.copy(policy_obj.polinfo_more)
		for key, value in infos.items():
			if key in policy_obj.polinfo:
				if isinstance(infos[key], (tuple, list)):
					continue
				infos[key]['value'] = policy_obj.polinfo[key]

		self.content_negotiation(infos)

class Operations(Ressource):
	"""GET /udm/progress/$progress-id (get the progress of a started operation like move, report, maybe add/put?, ...)"""


if __name__ == "__main__":
	application = Application([
		(r"/udm/", MainHandler),
		(r"/udm/([a-z]+)/", MainTypes),
		(r"/udm/([a-z]+/[a-z]+)/object-types/", ObjectTypes),
		(r"/udm/navigation/object-types/", ObjectTypesNavigation),
		(r"/udm/((?:[a-z]+/[a-z]+)|navigation)/containers/", Navigation),
		(r"/udm/(([a-z]+/[a-z]+)|navigation)/move-destinations/", MoveDestinations),
		(r"/udm/([a-z]+/[a-z]+)/options", Options),
		(r"/udm/([a-z]+/[a-z]+)/templates", Templates),
		(r"/udm/([a-z]+/[a-z]+)/containers", Containers),
		(r"/udm/([a-z]+/[a-z]+)/policies", Policies),
		(r"/udm/([a-z]+/[a-z]+)/report-types", ReportTypes),
		(r"/udm/([a-z]+/[a-z]+)/report/([^/]+)", Report),
		(r"/udm/([a-z]+/[a-z]+)/([^/]+)/properties/", Properties),
		(r"/udm/([a-z]+/[a-z]+)/([^/]+)/properties/([^/]+)/choices", PropertyChoices),
		(r"/udm/([a-z]+/[a-z]+)/properties/([^/]+)/default", DefaultValue),
		(r"/udm/([a-z]+/[a-z]+)/([^/]+)/(policies/[a-z]+)/", PolicyTypes),
		(r"/udm/([a-z]+/[a-z]+)/(policies/[a-z]+)/([^/]+)/", PolicyResult),
		(r"/udm/([a-z]+/[a-z]+)/", Objects),
		(r"/udm/([a-z]+/[a-z]+)/([^/]+)", Object),
		(r"/udm/([a-z]+/[a-z]+)/([^/]*)/layout", Layout),
		(r"/udm/networks/network/([^/]+)/next-free-ip-address", NextFreeIpAddress),
		(r"/udm/progress/$progress-id", Operations),  # operations?
		# TODO: possible move locations
		# TODO: meta info
		# TODO: decorator for dn argument, which makes sure no invalid dn syntax is used
	])
	application.listen(8888)
	tornado.ioloop.IOLoop.current().start()
